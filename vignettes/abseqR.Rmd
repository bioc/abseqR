---
params:
    # set to TRUE to render the "release" version of this vignette
    # NOTE: before you can run this with FALSE, at it at least once with TRUE to
    #       get all the files you require for release = FALSE
    release: TRUE
title: "abseqR"
author: "Jia Hong Fong"
package: "abseqR"
output:
    BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{Introduction to abseqR}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
library(abseqR)
library(png)
library(plotly)
library(grid)
library(gridExtra)
# knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

```{r environment_setup_no_release, include=FALSE, eval=(!params$release)}

# loads the necessary variables for this Rmd
# the reason for this is because we want the return values,
# but not the execution time (only executes when in 'debug' mode)

sandboxDirectory <- "."
toyDataPath <- file.path(sandboxDirectory, "abseqR_example")
if (!file.exists(toyDataPath)) {
    stop(paste("You must run this vignette with release = TRUE at least",
               "once before you run it with release = FALSE"))
}
```
```{r environment_setup_release, include=FALSE, eval=params$release}
# make sure that any existing copy of "abseqR_exmple" has been removed before
# we re-generate this vignette
lapply(c("abseqR_example", "refined_comparison"), unlink, recursive = TRUE)
```

```{r abseqR_vignette_helper_functions, include=FALSE}
sabseqR <- function() { return(Biocpkg("abseqR")); }
#sabseqR <- function() { return("`abseqR`"); }
sabseqPy <- function() { return("`abseqPy`"); }
sabseq <- function() { return("`AbSeq`"); }
```

# Introduction

A plethora of high throughput sequencing (HTS) analysis pipelines are
available as open source tools to analyze and validate the quality of Rep-seq [^Repseq] datasets.
[OmicTools](https://omictools.com/search?q=repertoire)
provides a summary of repertoire sequencing tools that implements different
techniques and algorithms in analyzing and visualizing datasets from B-cell
receptors (BCR) and T-cell receptors (TCR). However, high throughput antibody
sequencing analysis pipelines are scarce.

`r sabseq()` is a family of tools
implemented in `R`(visualizations and statistics) and `Python`(backend algorithm)
meant to be used together to provide insight to antibody repertoires.
Under the umbrella of `r sabseq()` is `r sabseqPy()` which processes paired-end
or single ended _FASTA/FASTQ_ files from Illumina MiSeq [@Illumina] into
csv files and HDF [@hdf] dataframes. The other is `r sabseqR()`, an R package that
visualizes the output of `r sabseqPy()` and presents the plots in a self-contained
HTML report. Furthermore, `r sabseqR()` provides an additional feature to
explicitly compare multiple samples against each other.

`r sabseqR()` provides the following functionality in addtion to `r sabseqPy()`:

* Visualizations: The output from `r sabseqPy()` is summarized succintly into
  plots saved as `PNG` and `Rdata` files. The latter provides flexibility for
  users to easily customize the aesthetics of any plots generated by `r sabseqR()`
 
* Collated report: The plots generated by `r sabseqR()` are collated and presented
  in a self-contained HTML document for convenience and ease of sharing.
  
* Sample comparison: `r sabseqR()` overloads the `+` operator
  via the S4 classes `AbSeqCRep` and `AbSeqRep`. To compare
  different samples against each other, the `+` operator can be used to
  specify the desired combinations. The "sample comparison" includes additional
  plots, for example, sample similarity clustering, overlapping clonotypes and
  more.
  

# Citation

TODO


# Installation

`r sabseqR()` can be installed from [bioconductor.org](http://bioconductor.org/) or
its GitHub repository at https://github.com/malhamdoosh/abseqR.

## Bioconductor

Install via `biocLite`:
```r
source("http://bioconductor.org/biocLite.R")
biocLite("abseqR")
```

## GitHub

Install via `devtools`:
```r
library(devtools)
install_github("malhamdoosh/abseqR")
```

## System prerequisites

`r sabseqR()` requires [pandoc](http://pandoc.org/) version _1.19.2.1_ or higher
to render the HTML report. If pandoc can not be detected while executing `r sabseqR()`,
the HTML report will __not__ be generated. `r sabseqR()` is a cross-platform
library and will work on any major operating system [^windows_biocparallel].

## R package dependencies

`r sabseqR()` depends on several packages from [CRAN](https://cran.r-project.org/)
and [Bioconductor](https://bioconductor.org/):

* `r CRANpkg("RColorBrewer")` provides colour
schemes for maps and graphics generated in this package. To install it, type 
`install.packages("RColorBrewer")`

* `r CRANpkg("VennDiagram")` provides a set of
functions to generate Venn diagrams. To install it, type `install.packages("VennDiagram")`

* `r CRANpkg("circlize")` is a visualization tool
used to summarize the distributions of associations between segments in this
package. To install it, type `install.packages("circlize")`

* `r CRANpkg("flexdashboard")` is a package
that provides a template for RMarkdown that resembles a grid oriented dashboard.
This is used to generate the HTML report in a dashboard fashion. To
install it, type `install.packages("flexdashboard")`

* `r CRANpkg("ggplot2")` is an implementation of
the "Grammar of Graphics" in R. It is used extensively within this package to
generate plots. To install it, type `install.packages("ggplot2")`

* `r CRANpkg("ggcorrplot")` is used to visualize
a correlation matrix using `r CRANpkg("ggplot2")`.
To install it, type `install.packages("ggcorrplot")`

* `r CRANpkg("ggdendro")` provides a set of tools
for drawing dendrograms and tree plots using `r CRANpkg("ggplot2")`. To install it, type
`install.packages("ggdendro")`

* `r CRANpkg("grid")` is used to arrange plots.
It has been integrated into the base R package.

* `r CRANpkg("gridExtra")` provides functions
to work with "grid" graphics, used in this package to arrange grid-based plots
in the HTML report. To install it, type `install.packages("gridExtra")`

* `r CRANpkg("knitr")` provides the capability to
dynamically generate reports in R. To install it, type `install.packages("knitr")`

* `r CRANpkg("plotly")` is used to translate
`r CRANpkg("ggplot2")` graphs to an interactive web-based version. To install it, type
`install.packages("plotly")`

* `r CRANpkg("plyr")` offers a set of tools used in
this package to apply operations on subsets of data in manageable pieces. To
install it, type `install.packages("plyr")`

* `r CRANpkg("png")` is used to read and display PNG images.
To install it, type `install.packages("png")`

* `r CRANpkg("reshape2")` allows this package to
restructure and aggregate dataframes. To install it, type `install.packages("reshape2")`

* `r CRANpkg("rmarkdown")` converts R Markdown
documents into a variety of formats. To install it, type `install.packages("rmarkdown")`

* `r CRANpkg("vegan")` [@vegan] provides a suite of functions
to calculate diversity and distance statistics between repertoires. To install it,
type `install.packages("vegan")`

* `r Biocpkg("BiocParallel")` is
a package from [Bioconductor](https://bioconductor.org) used to parallelize
operations in this package. To install it, type
```r
## try http:// if https:// URLs are not supported
        source("https://bioconductor.org/biocLite.R")
        biocLite("BiocParallel")
```

# Quick start

To leverage _all_ the functionalities provided by `r sabseqR()`, the main
functions to note are `abseqR::abseqReport`, `abseqR::report`, and `+`.
This section will use a toy example to walk through the use cases of each function.

TODO: show class diagram here

## Dataset

The toy example mentioned previously comes installed with `r sabseqR()`.
For the sake of brevity, the samples are described under the
[miscellaneous](#toy-data) section. Briefly, the dataset contains 3 samples generated
from _in silico_ simulation, each named PCR1, PCR2, and PCR3.
The output directory specified in `r sabseqPy()`'s `--outdir` was
`"abseqR_example"`

### Obtaining the toy dataset {#obtain-dataset}

To obtain the dataset, the following R code demonstrates the steps needed to copy it
to a _sandbox directory_:

```{r abseqR_copy_data_files, eval=params$release, results=FALSE}
# substitute with any directory that you have read/write access to
sandboxDirectory <- "."
if (!file.exists(sandboxDirectory)) {
    file.create(sandboxDirectory)
}

# path to provided toy data (comes installed with abseqR)
toyData <- system.file("extdata", "abseqR_example", package = "abseqR")
# copy the provided toy data to sandboxDirectory
file.copy(toyData, sandboxDirectory, recursive = TRUE)
```

### Exploring the toy dataset

To verify that the 3 `PCR`s are present:

```{r abseqR_data_contents}
# toyDataPath now holds the path to a local copy of the toy data
toyDataPath <- file.path(sandboxDirectory, "abseqR_example")
# the sample names can be found inside the auxiliary directory
list.files(path = file.path(toyDataPath, "auxiliary"))
```


## Analyzing the datasets

### Basic analysis with `abseqReport` {#basic-analysis}

After [obtaining the dataset](#obtain-dataset), visualizing the results of
`r sabseqPy()` is done using the `abseqReport` function.

```{r abseqR_quick_run, eval=FALSE, results=FALSE, warning=FALSE}
# visualize all the datasets individually,
# then "compare" PCR1 with PCR2 with PCR3
samples <-  abseqReport(toyDataPath,
                        compare = c("PCR1, PCR2, PCR3"))

# ignore the warning message:
# "Sample output directory <path> is different from provided path
#   <path> assuming directory was moved"
# This warning message tells us that the directory has
# been moved (we copied the provided examples to "toyDataPath")
```
<!-- We showed the users with report = 3, however that's redundant
in this vignette because we're not going to be using the HTML report - the
users are advised to explore the HTML themselves.
Save time by only plotting the PNGs -->
```{r abseqR_quick_run_hidden, eval=TRUE, echo=FALSE, results=FALSE, warning=FALSE}
samples <- abseqReport(toyDataPath, compare = c("PCR1,PCR2,PCR3"), report = 1)
```

`abseqReport` will look for samples contained within `toyDataPath` and create
visuals for all of them. In addition, `compare = c("PCR1, PCR2, PCR3")` specifies
that samples named `PCR1`, `PCR2`, and `PCR3` should be compared against each
other. Other possible arguments to `compare` will be described in
detail in the next [section](#abseqReport-compare).

The above call to `abseqReport` generates PNG plots in the same folder as the
corresponding csv files within `auxiliary` but they are
collated together in a standalone HTML document found in the `report` directory.

The contents inside the `report` directory:

* `index.html` is a document which summarizes the analysis and provides a convenient way
of navigating to multiple samples. For example, within this file, there are links to
the reports generated for `PCR1`, `PCR2`, `PCR3` and `PCR1 vs PCR2 vs PCR3`.

* `html_files` contains individual HTML files that are _not_ meant to be accessed by the user,
but rather through `index.html`. The files within this directory are standalone HTML documents,
but the landing page `index.html` (is **not** because it) contains relative links to the aforementioned HTML documents,
and should be shared together with the `html_files` folder.

In conclusion, the folder of interest is `report`, and the file of interest is
`index.html`. The individual sample reports (HTML files) in `html_files` can
be shared as-is, but it is recommended to share the `report` folder in its entirety.


### Configuring sample comparison in `abseqReport` {#abseqReport-compare}

This section describes the possible inputs for `abseqReport`'s
`compare` parameter. Earlier, `abseqReport` was called with
`compare = c("PCR1, PCR2, PCR3")`. This tells the function to
compare "`PCR1` with `PCR2` with `PCR3`". However,
it is also possible to compare only a subset of samples in `toyDataPath`,
or multiple subsets of samples, or none at all.

The `compare` parameter accepts a vector of one or more strings. Each string
denotes a comparison between samples separated by commas
(e.g. `compare = c("PCR1, PCR2, PCR3")`)[^compare-ws].

If sample comparison was not required, then the command can be
simplified to `samples <- abseqReport(toyDataPath)`.

Example of other combinations:

```{r abseqR_abseqReport_compare_argument, eval=FALSE}
# Example of 1 comparison
# Analyze all samples, but only compare PCR1 with PCR2
pcr1.pcr2 <- abseqReport(toyDataPath, compare = c("PCR1,PCR2"))

# Example of 3 comparisons
# Analyze all samples. In addition, compare:
#  * PCR1 with PCR2
#  * PCR2 with PCR3
multiComparison <- abseqReport(toyDataPath, compare = c("PCR1,PCR2",
                                                        "PCR2,PCR3"))
```
<!-- always execute this chunk, these are used in demonstration examples
that don't require any run -->
```{r abseqR_abseqReport_copare_argument_hidden, echo=FALSE, eval=TRUE}
pcr1.pcr2 <- suppressWarnings(abseqReport(toyDataPath, compare = c("PCR1,PCR2"),
                              report = 0))
multiComparison <- suppressWarnings(abseqReport(toyDataPath, compare = c(
    "PCR1,PCR2",
    "PCR2,PCR3"
), report = 0))
```

__Note__, `abseqReport` always return _all_ samples in `toyDataPath`.
That is, the following is always true regardless of the arguments
to `compare`:

```{r abseqR_show_return_of_abseqReport, eval=TRUE}
# both had different values to "compare", but they both still return all 3 PCRs
cat(names(pcr1.pcr2))
names(multiComparison)
```
The next subsection explains the motivation for this behaviour.

### Customizing sample comparison with `report` {#customize-cmp}

[Previously](#basic-analysis), the return value of `abseqReport` was stored in a variable
named `samples`. This allows for further customizations in sample comparison.

As a hypothetical example,
if the reports show an interesting behaviour between `PCR1` and `PCR3`,
it might be of interest to isolate the 2 samples from the rest. That is,
comparing `PCR1` with `PCR3` exclusively instead of a comparison with all 3 `PCR`s,
as was done before.

This code shows how to further refine sample comparisons:

```{r abseqR_refine_comparison_simple, eval=FALSE, results=FALSE, warning=FALSE}
# recall that samples is a named list
# where each element's name is the sample's own name (see names(samples))
pcr1.pcr3 <- samples[["PCR1"]] + samples[["PCR3"]]
refinedComparison <- report(pcr1.pcr3,
                            outputDir = file.path(sandboxDirectory,
                                                  "refined_comparison"))
```

```{r abseqR_refine_comparison_simple_hidden, eval=TRUE, echo=FALSE, results=FALSE, warning=FALSE}
pcr1.pcr3 <- samples[["PCR1"]] + samples[["PCR3"]]
refinedComparison <- report(pcr1.pcr3,
                            outputDir = file.path(sandboxDirectory,
                                                  "refined_comparison"),
                            report = 1)
```

Here, the `+` operator creates a new comparison between`PCR1` and `PCR3`.
The return value of this expression was used
as the first argument to `r sabseqR()`'s `report` function. The second argument
of `report` specifies the directory where the results should be stored.

Analogous to `abseqReport`, this function will generate a standalone HTML report in the
output directory. The return value of this function is consistent with `abseqReport`,
in which it returns all the samples in its first argument - `PCR1` and `PCR3`.

```{r abseqR_refine_comparison_sample_return_value, eval=TRUE}
names(refinedComparison)
```

In conclusion, the return value is valuable when there is a need to refine the
comparison between samples. It can be accomplished using `+` and the `report`
function.

# Advanced Examples

## Comparing samples from different abseqPy output directories

Occasionally, it might be useful to compare datasets from different `r sabseq()`
directories. For example:

```{bash abseqR_different_dirs, eval=FALSE}
# first abseqPy run on SRR dataset from control group
abseq --file1 fasta/SRR_ACGT_CTRL.fasta --outdir SRR_CTRL

# second abseqPy run on SRR dataset from experiment group
abseq --file1 fasta/SRR_ACGT_EXP.fasta --outdir SRR_EXP
```

analyzing these samples in `r sabseqR()`:

```{r abseqR_adv_load_samples, eval=FALSE}
SRRControl <- abseqReport("SRR_CTRL")
SRRExp <- abseqReport("SRR_EXP")
```

then comparing _all_ samples in `SRRControl` with _all_ samples in `SRRExp`
can be done using [using `+` and `report`](#customize-cmp).

```{r abseqR_adv_compare_old_new, eval=FALSE}
# short for SRRControl[[1]] + SRRControl[[2]] + ... + SRRExp[[1]] + ...
all.samples <- Reduce("+", c(SRRControl, SRRExp))
report(all.samples, outputDir = "SRRControl_vs_SRRExp")
```

> **Important**: The sample names in `SRR_CTRL` and `SRR_EXP` _must_ be unique.


## Lazy loading

In the previous section, the `SRRControl` dataset was loaded using
`SRRControl <- abseqReport("SRR_CTRL")` because its return value was required
before it can be used to compare with `SRRExp` in
`all.samples <- Reduce("+", c(SRRControl, SRRExp))`.
However, this is inefficent because `SRRControl <- abseqReport("SRR_CTRL")`
will **regenerate** all visuals and reports.
This dataset might have already been analyzed long before the `SRRExp`
dataset came along.

Instead, the following function call will let `abseqReport` know that it should
_do nothing_ and return what it usually returns (a _named list_ of samples in `SRRControl`).

```{r abseqR_adv_lazy_load, eval=FALSE}
# in essence, this is identical to SRRControl <- abseqReport("SRR_CTRL"),
# but will not regenerate plots and reports!
SRRControl.lazy <- abseqReport("SRR_CTRL", report = 0)

# exactly the same return value
stopifnot(names(SRRControl.lazy) == names(SRRControl))
```

The same applies to the `SRRExp` sample.

## Fine-tuning reports 

In the previous section, the `report` parameter of `abseqReport` was used to
"load" the samples in `SRRControl` without actually plotting any data. 
The `report` parameter is capable of accepting 4 values:

1. `abseqReport("SRR_CTRL", report = 0)` does nothing and returns a named list of
samples in the directory "SRR_CTRL".

2. `abseqReport("SRR_CTRL", report = 1)` plots PNGs but **does not** generate
HTML reports. That is, it will only create PNG plots of the data files generated
by `r sabseqPy()` without collating them into a HTML document.

3. `abseqReport("SRR_CTRL", report = 2)` plots PNGs and generates HTML reports, but
the graphs in the HTML reports are **static**. That is, it does exactly what
`report = 1` does, but also collects them and embeds the PNGs into
a standalone HTML report.

4. `abseqReport("SRR_CTRL", report = 3)` plots PNGs and interactive HTML reports.
That is, it does exactly what `report = 2` does, but also adds interactivity to
the embedded PNGs using [plotly](https://cran.r-project.org/package=plotly).
This is the default behaviour when `report` is not specified.

In all 4 cases, it will always return a named list of all samples in the
directory `SRR_CTRL`.


## Fine-tuning parallelization

`abseqReport` also accepts an optional parameter `BPPARAM`. This parameter
will be passed into `BiocParallel::bplapply` for parallelization. More
information regarding the accepted values to `BPPARAM` can be found in
BiocParallel's
[page](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html).

Below is a simplified example of using 4 cores and serializing the loop.

```{r abseqR_adv_bpparam, eval=FALSE}

# use 4 CPU cores
nproc <- 4
samples <- abseqReport(toyDataPath,
                       BPPARAM = BiocParallel::MulticoreParam(nproc))


# run sequentially - no multiprocessing
samples <- abseqReport(toyDataPath,
                       BPPARAM = BiocParallel::SerialParam())
```

# abseqR on simulated data {#abseqR-interpret}

```{r abseqR_plot_path_setup, include=FALSE}
# [s]ingle sample [dir]ectory
sdir <- file.path(toyDataPath, "auxiliary", "PCR1")
# [m]ulti sample [dir]ectory
mdir <- file.path(toyDataPath, "auxiliary", "PCR1_vs_PCR2_vs_PCR3")
```

This section aims to walk through each plot generated by `r sabseqR()` when
the `abseqReport` or `report` function was invoked on the provided `PCR` samples.
The visualizations and analyses can be broken down into 5 categories:

1. Sequence quality
2. V-(D)-J germline abundance
3. Clonotype productivity analysis (also referred as functional clones)
4. Clonotype diversity analysis
5. Overlapping clonotypes analysis

It is important to note that all the graphs generated by `r sabseqR()` are
plotted **after** the filtering criteria specified in `r sabseqPy()`
has been applied on the sequences.

## Sequence quality

The plots in this section can be found in the `annot` and `abundance` directory
of `PCR1` or in the `Summary` and `Quality` tab in `PCR1`'s HTML report.

### Sequence length

The sequence length distribution of a sample is of great interest when attempting
to validate the quality of a sequencing run. 

```{r seq-len, fig.cap="Sequence length distribution. Shows the sequence length distribution of (merged) raw reads post filtering.", echo=FALSE}
load(file.path(sdir, "annot", "PCR1_all_clones_len_dist.Rdata"))
plot
```

Figure \@ref(fig:seq-len) plots sequence length (x-axis) against proportion (y-axis).
A similar plot with outliers removed can be found in the same directory.

### Alignment quality

Recall that the filtering criteria of `r sabseqPy()` on v genes consist of:

1. Bitscore
2. Subject start index
3. Query start index
4. Alignment length

Setting the filtering criteria for `r sabseqPy()` might be challenging on new datasets --
stringent values might filter too many sequences while lenient values might retain
noise.

Figure \@ref(fig:align-qual) shows the percentage of sequences that will be retained when a given
value is chosen for filtering.

```{r align-qual, fig.cap="Alignment quality heatmaps. From left to right: bitscore, percent identity, gaps, and mismatches against the alignment length. Last plot shows subject vs query start index.", echo=FALSE, fig.wide=TRUE}
bitscoreHM <- file.path(sdir, "abundance", "PCR1_igv_align_quality_bitscore_hm_static.png")
identityHM <- file.path(sdir, "abundance", "PCR1_igv_align_quality_identity_hm_static.png")
gapsHM <- file.path(sdir, "abundance", "PCR1_igv_align_quality_gaps_hm_static.png")
misHM <- file.path(sdir, "abundance", "PCR1_igv_align_quality_mismatches_hm_static.png")
startHM <- file.path(sdir, "abundance", "PCR1_igv_align_quality_start_hm_static.png")
bitscoreHM <- rasterGrob(as.raster(readPNG(bitscoreHM)), interpolate = FALSE)
identityHM <- rasterGrob(as.raster(readPNG(identityHM)), interpolate = FALSE)
gapsHM <- rasterGrob(as.raster(readPNG(gapsHM)), interpolate = FALSE)
misHM <- rasterGrob(as.raster(readPNG(misHM)), interpolate = FALSE)
startHM <- rasterGrob(as.raster(readPNG(startHM)), interpolate = FALSE)
grid.arrange(bitscoreHM, identityHM, gapsHM, misHM, startHM, nrow = 2)
```

They provide a good starting point in choosing the right values for filtering.

### Gaps and mismatches

Gaps (insertions or deletions -- _indels_) and mismatches are also a common
marker for sequence quality.
Figure \@ref(fig:indel) and \@ref(fig:mis) shows the percentage of sequences for a
given number of gaps or mismatches.

```{r indel, fig.cap="Rate of insertions and deletions in V genes.", echo=FALSE}
load(file.path(sdir, "abundance", "PCR1_igv_gaps_dist.Rdata"))
plot
```

```{r mis, fig.cap="Mismatch rate in V genes.", echo=FALSE}
load(file.path(sdir, "abundance", "PCR1_igv_mismatches_dist.Rdata"))
plot
```

## V-(D)-J germline abundance

The plots in this section can be found in the `abundance` directory
of `PCR1` or in the `Abundance` tab in `PCR1`'s HTML report.

### Germline abundance

```{r vgermline, fig.cap="V family germline distribution", echo=FALSE}
load(file.path(sdir, "abundance", "PCR1_igv_dist_family_level.Rdata"))
plot
```

Figure \@ref(fig:vgermline) shows the proprotion in percentage of sequences
belonging in different V "family" germlines.
The granularity can be adjusted between V-family (e.g. `IGHV3`) and
V-gene (e.g. `IGHV3-9`); these plots are available
in the same directory. The same applies to _D_ and _J_ genes.

### V-J germline associations

Figure \@ref(fig:vjassoc) summarizes the associations between V
and J family germlines in a plot generated using `r CRANpkg("circlize")`
(inspired by [VDJTools](https://github.com/mikessh/vdjtools/)[@vdjtools] )


```{r vjassoc, fig.cap="V-J family germline association. Segment size represents germline proportion while the thickness of the arcs shows the proportion of associations between V and J families.", echo=FALSE}
grid.raster(readPNG(file.path(sdir, "abundance", "PCR1_vjassoc.png")))
```


# Miscellaneous

## Dataset {#toy-data}

The toy dataset used in the above examples
was obtained from a combination of synthetic sample datasets generated
using [MiXCR](https://github.com/milaboratory/mixcr)'s program 
[here](http://files.milaboratory.com/mixcr/paper/mixcr-test-1.2-SNAPSHOT.jar). 
Firstly, three distinct samples were generated, each simulated with the following parameters
in `MiXCR`:
```
* reads   = 10000, 10000, 10000
* clones  =  5000,  5000,  2000
* seed    =  4228,  2428,  2842
* conf    = MiSeq-300-300      (for all 3)
* loci    = IGH                (for all 3)
* species = hsa                (for all 3)
```

Following that, to introduce overlapping sequences between the samples, a script was written
to randomly mix and amplify sequences from these samples, resulting in a final
repertoire of 3 samples, named PCR1, PCR2, and PCR3.

Finally, these 3 samples were analyzed by `r sabseqPy()`. The command used to
analyze these samples are as follows:

```{bash abseqR_toy_data_abseqPy_run, eval=FALSE}
abseq -y toy.yml
```

where the contents of `toy.yml` is:

```yaml
# toy.yml
defaults:
    bitscore: 300
    sstart: 1-3
    alignlen: 250
    outdir: abseqR_example
    task: all
    threads: 1
---
file1: PCR1.fasta
name: PCR1
---
file1: PCR2.fasta
name: PCR2
---
file1: PCR3.fasta
name: PCR3
```

These 3 samples form the final toy dataset described in this vignette.

# Session Info

```{r abseqR_session_info, echo=FALSE}
sessionInfo()
```

[^Repseq]: Repertoire sequencing
[^windows_biocparallel]: The performace offered by
[BiocParallel](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html) may differ across OSes
[^compare-ws]: Trailing and leading whitespace between sample names are trimmed. That is, "PCR1,PCR2" is identical to
"PCR1 , PCR2"


# References
<!-- automatically inserted -->

