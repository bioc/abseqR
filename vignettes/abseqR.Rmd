---
title: "abseqR"
author: "Jia Hong Fong"
package: "abseqR"
output:
    BiocStyle::html_document: default
    BiocStyle::pdf_document:
vignette: >
    %\VignetteIndexEntry{Introduction to abseqR}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(abseqR)
library(png)
library(plotly)
library(grid)
library(gridExtra)
# knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

```{r environment_setup_release, include=FALSE}
# make sure that any existing copy of "ex" has been removed before
# we re-generate this vignette
lapply(c("ex", "refined_comparison"), unlink, recursive = TRUE)
```

```{r abseqR_vignette_helper_functions, include=FALSE}
sabseqR <- function() { return(Biocpkg("abseqR")); }
#sabseqR <- function() { return("`abseqR`"); }
sabseqPy <- function() { return("[abseqPy](https://github.com/malhamdoosh/abseqPy)"); }
sabseq <- function() { return("`AbSeq`"); }
```

# Introduction

A plethora of high throughput sequencing (HTS) analysis pipelines are
available as open source tools to analyze and validate the quality of Rep-seq [^Repseq] datasets.
[OmicTools](https://omictools.com/search?q=repertoire)
provides a summary of repertoire sequencing tools that implements different
techniques and algorithms in analyzing and visualizing datasets from B-cell
receptors (BCR) and T-cell receptors (TCR). However, high throughput antibody
sequencing analysis pipelines are scarce.

`r sabseq()` is a family of tools
implemented in `R`(visualizations and statistics) and `Python`(backend algorithm)
meant to be used together to provide insight to antibody repertoires.
Under the umbrella of `r sabseq()` is `r sabseqPy()` which processes paired-end
or single ended _FASTA/FASTQ_ files from Illumina MiSeq into
csv files and [HDFs](https://portal.hdfgroup.org/display/support).
The other is `r sabseqR()`, an R package that
visualizes the output of `r sabseqPy()` and presents the plots in a self-contained
HTML report. Furthermore, `r sabseqR()` provides an additional feature to
explicitly compare multiple samples against each other.

`r sabseqR()` provides the following functionality in addtion to `r sabseqPy()`:

* Visualizations: The output from `r sabseqPy()` is summarized succintly into
  plots saved as `PNG` and `Rdata` files. The latter provides flexibility for
  users to easily customize the aesthetics of any plots generated by `r sabseqR()`
 
* Collated report: The plots generated by `r sabseqR()` are collated and presented
  in a self-contained HTML document for convenience and ease of sharing.
  
* Sample comparison: `r sabseqR()` overloads the `+` operator
  via the S4 classes `AbSeqCRep` and `AbSeqRep`. To compare
  different samples against each other, the `+` operator can be used to
  specify the desired combinations. The "sample comparison" includes additional
  plots, for example, sample similarity clustering, overlapping clonotypes and
  more.
  

# Installation

`r sabseqR()` can be installed from [bioconductor.org](http://bioconductor.org/) or
its GitHub repository at https://github.com/malhamdoosh/abseqR.

## Bioconductor

Install via `BiocManager`:
```r
if (!require("BiocManager"))
    install.packages("BiocManager")
BiocManager::install("abseqR")
```

## GitHub

Install via `devtools`:
```r
if (!require("devtools"))
    install.packages("devtools")
devtools::install_github("malhamdoosh/abseqR")
```

## System prerequisites

`r sabseqR()` requires [pandoc](http://pandoc.org/) version _1.19.2.1_ or higher
to render the HTML report. If pandoc cannot be detected while executing `r sabseqR()`,
the HTML report will __not__ be generated. `r sabseqR()` is a cross-platform
library and will work on any major operating system [^windows_biocparallel].

## R package dependencies

`r sabseqR()` depends on several packages from [CRAN](https://cran.r-project.org/)
and [Bioconductor](https://bioconductor.org/):

* `r CRANpkg("RColorBrewer")` provides colour
schemes for maps and graphics generated in this package. To install it, type 
`install.packages("RColorBrewer")`

* `r CRANpkg("VennDiagram")` provides a set of
functions to generate Venn diagrams. To install it, type `install.packages("VennDiagram")`

* `r CRANpkg("circlize")` is a visualization tool
used to summarize the distributions of associations between segments in this
package. To install it, type `install.packages("circlize")`

* `r CRANpkg("flexdashboard")` is a package
that provides a template for RMarkdown that resembles a grid oriented dashboard.
This is used to generate the HTML report in a dashboard fashion. To
install it, type `install.packages("flexdashboard")`

* `r CRANpkg("ggplot2")` is an implementation of
the "Grammar of Graphics" in R. It is used extensively within this package to
generate plots. To install it, type `install.packages("ggplot2")`

* `r CRANpkg("ggcorrplot")` is used to visualize
a correlation matrix using `r CRANpkg("ggplot2")`.
To install it, type `install.packages("ggcorrplot")`

* `r CRANpkg("ggdendro")` provides a set of tools
for drawing dendrograms and tree plots using `r CRANpkg("ggplot2")`. To install it, type
`install.packages("ggdendro")`

* `r CRANpkg("grid")` is used to arrange plots.
It has been integrated into the base R package.

* `r CRANpkg("gridExtra")` provides functions
to work with "grid" graphics, used in this package to arrange grid-based plots
in the HTML report. To install it, type `install.packages("gridExtra")`

* `r CRANpkg("knitr")` provides the capability to
dynamically generate reports in R. To install it, type `install.packages("knitr")`

* `r CRANpkg("plotly")` is used to translate
`r CRANpkg("ggplot2")` graphs to an interactive web-based version. To install it, type
`install.packages("plotly")`

* `r CRANpkg("plyr")` offers a set of tools used in
this package to apply operations on subsets of data in manageable pieces. To
install it, type `install.packages("plyr")`

* `r CRANpkg("png")` is used to read and display PNG images.
To install it, type `install.packages("png")`

* `r CRANpkg("reshape2")` allows this package to
restructure and aggregate dataframes. To install it, type `install.packages("reshape2")`

* `r CRANpkg("rmarkdown")` converts R Markdown
documents into a variety of formats. To install it, type `install.packages("rmarkdown")`

* `r CRANpkg("vegan")` provides a suite of functions
to calculate diversity and distance statistics between repertoires. To install it,
type `install.packages("vegan")`

* `r Biocpkg("BiocParallel")` is
a package from [Bioconductor](https://bioconductor.org) used to parallelize
operations in this package. To install it, type
```r
## try http:// if https:// URLs are not supported
        source("https://bioconductor.org/biocLite.R")
        biocLite("BiocParallel")
```

# Quick start

To leverage all the functionalities provided by `r sabseqR()`, the main
functions to note are `abseqR::abseqReport`, `abseqR::report`, and `+`.
This section will use a small dataset to walk through the use cases of each function.

## Dataset

The example dataset comes installed with `r sabseqR()`.
For the sake of brevity, the samples are described under the
[miscellaneous](#example-data) section.

Briefly, the dataset contains 3 samples generated using
_in silico_ simulation, named PCR1, PCR2, and PCR3.
`r sabseqPy()` was then used to analyze the dataset and
the output directory specified in `r sabseqPy()`'s `--outdir` was
`"ex"`.

### Obtaining the dataset {#obtain-dataset}

To obtain the dataset, the following R code demonstrates
the steps needed to copy it to a _sandbox directory_:

```{r abseqR_copy_data_files, results=FALSE}
# substitute with any directory that you have read/write access to
sandboxDirectory <- "."
if (!file.exists(sandboxDirectory)) {
    file.create(sandboxDirectory)
}

# path to provided data (comes installed with abseqR)
exdata <- system.file("extdata", "ex", package = "abseqR")
# copy the provided data to sandboxDirectory
file.copy(exdata, sandboxDirectory, recursive = TRUE)
```

### Exploring the dataset

To verify that the 3 `PCR`s are present:

```{r abseqR_data_contents}
# dataPath now holds the path to a local copy of the data
dataPath <- file.path(sandboxDirectory, "ex")
# the sample names can be found inside the auxiliary directory
list.files(path = file.path(dataPath, "auxiliary"))
```


## Analyzing the dataset

### Basic analysis with `abseqReport` {#basic-analysis}

After [obtaining the dataset](#obtain-dataset), visualizing the results of
`r sabseqPy()` is done using the `abseqReport` function.

```{r abseqR_quick_run, eval=FALSE, results=FALSE, warning=FALSE}
# visualize all the datasets individually,
# then "compare" PCR1 with PCR2 with PCR3
samples <-  abseqReport(dataPath,
                        compare = c("PCR1, PCR2, PCR3"))

# ignore the warning message:
# "Sample output directory <path> is different from provided path
#   <path> assuming directory was moved"
# This warning message tells us that the directory has
# been moved (we copied the provided examples to "dataPath")
```
<!-- We showed the users with report = 3, however that's redundant
in this vignette because we're not going to be using the HTML report - the
users are advised to explore the HTML themselves.
Save time by only plotting the PNGs -->
```{r abseqR_quick_run_hidden, eval=TRUE, echo=FALSE, results=FALSE, warning=FALSE}
samples <- abseqReport(dataPath, compare = c("PCR1,PCR2,PCR3"), report = 1)
```

The call to `abseqReport` create plots for all samples contained within `dataPath`.
In addition, `compare = c("PCR1, PCR2, PCR3")` specifies
that samples named `PCR1`, `PCR2`, and `PCR3` should be explicitly
compared against each other. Other possible arguments to
`compare` will be described in detail in the next [section](#abseqReport-compare).

### Sharing output

Invoking `abseqReport` generates PNG plots in the same folder as the
corresponding csv files within `auxiliary` but they are
collated together in a standalone HTML document found in the `report` directory.

The contents inside the `report` directory:

* `index.html` is a document which summarizes the analysis and provides a convenient way
of navigating to multiple samples. For example, within this file, there are links to
the reports generated for `PCR1`, `PCR2`, `PCR3` and `PCR1 vs PCR2 vs PCR3`.

* `html_files` contains individual HTML files that are _not_ meant to be accessed by the user,
but rather through `index.html`. The files within this directory are standalone HTML documents,
but the landing page `index.html` (is **not** because it)
contains relative links to the aforementioned HTML documents, and should be
shared together with the `html_files` folder.

In conclusion, the folder of interest is `report`, and the file of interest is
`index.html`. The individual sample reports (HTML files) in `html_files` can
be shared as-is, but `index.html` __must__ be accompanied by `html_files` folder.


It is recommended to share the `report` folder in its entirety.


### Configuring sample comparison in `abseqReport` {#abseqReport-compare}

This section describes the possible inputs for `abseqReport`'s
`compare` parameter. Earlier, `abseqReport` was called with
`compare = c("PCR1, PCR2, PCR3")`. This tells the function to
compare "`PCR1` with `PCR2` with `PCR3`". However,
it is also possible to compare only a subset of samples in `dataPath`,
or multiple subsets of samples, or none at all.

The `compare` parameter accepts a vector of one or more strings. Each string
denotes a comparison between samples separated by commas, for example,
`compare = c("PCR1, PCR2, PCR3")`[^compare-ws].

If sample comparison was not required, then the command can be
simplified to `samples <- abseqReport(dataPath)`.

Example of other combinations:

```{r abseqR_abseqReport_compare_argument, eval=FALSE}
# Example of 1 comparison
# Analyze all samples, but only compare PCR1 with PCR2
pcr1.pcr2 <- abseqReport(dataPath, compare = c("PCR1, PCR2"))

# Example of 3 comparisons
# Analyze all samples. In addition, compare:
#  * PCR1 with PCR2
#  * PCR2 with PCR3
multiComparison <- abseqReport(dataPath, compare = c("PCR1, PCR2",
                                                     "PCR2, PCR3"))
```
<!-- always execute this chunk, these are used in demonstration examples
that don't require any run -->
```{r abseqR_abseqReport_copare_argument_hidden, echo=FALSE, eval=TRUE}
pcr1.pcr2 <- suppressWarnings(abseqReport(dataPath, compare = c("PCR1,PCR2"),
                              report = 0))
multiComparison <- suppressWarnings(abseqReport(dataPath, compare = c(
    "PCR1,PCR2",
    "PCR2,PCR3"
), report = 0))
```

__Note__, `abseqReport` always return _all_ samples in `dataPath` regardless
of the arguments in `compare`:

```{r abseqR_show_return_of_abseqReport, eval=TRUE}
# compare = c("PCR1,PCR2")
names(pcr1.pcr2)

# compare = c("PCR1, PCR2", "PCR2 ,PCR3")
names(multiComparison)
```
The next subsection explains the motivation for this behaviour.

### Customizing sample comparison with `report` {#customize-cmp}

[Previously](#basic-analysis), the return value of `abseqReport` was stored in a variable
named `samples`.
This return value can be used to further customize sample comparisons.

As a hypothetical example,
if the reports show an interesting observation between `PCR1` and `PCR3`,
it might be of interest to isolate the 2 samples from the rest. That is,
comparing `PCR1` with `PCR3` exclusively.

This code shows how to further refine sample comparisons:

```{r abseqR_refine_comparison_simple, eval=FALSE, results=FALSE, warning=FALSE}
# recall that samples is a named list
# where each element's name is the sample's own name (see names(samples))
pcr1.pcr3 <- samples[["PCR1"]] + samples[["PCR3"]]
refinedComparison <- report(pcr1.pcr3,
                            outputDir = file.path(sandboxDirectory,
                                                  "refined_comparison"))
```

```{r abseqR_refine_comparison_simple_hidden, eval=TRUE, echo=FALSE, results=FALSE, warning=FALSE}
pcr1.pcr3 <- samples[["PCR1"]] + samples[["PCR3"]]
refinedComparison <- report(pcr1.pcr3,
                            outputDir = file.path(sandboxDirectory,
                                                  "refined_comparison"),
                            report = 1)
```

Here, the `+` operator creates a new comparison between `PCR1` and `PCR3`.
The return value of this expression was used
as the first argument to `r sabseqR()`'s `report` function. The second argument
of `report` specifies the directory where the results should be stored.

Analogous to `abseqReport`, this function will generate a standalone HTML report in the
output directory. The return value of this function is consistent with `abseqReport`,
in which it returns all the samples in its first argument - `PCR1` and `PCR3`.

```{r abseqR_refine_comparison_sample_return_value, eval=TRUE}
names(refinedComparison)
```

In conclusion, the return value is valuable when there is a need to refine the
comparison between samples. It can be accomplished using `+` and the `report`
function.

# Advanced Examples

## Comparing samples from different abseqPy output directories

Occasionally, it might be useful to compare datasets from different `r sabseq()`
directories. For example:

```{bash abseqR_different_dirs, eval=FALSE}
# first abseqPy run on SRR dataset from control group
abseq --file1 fasta/SRR_ACGT_CTRL.fasta --outdir SRR_CTRL

# second abseqPy run on SRR dataset from experiment group
abseq --file1 fasta/SRR_ACGT_EXP.fasta --outdir SRR_EXP
```

analyzing these samples in `r sabseqR()`:

```{r abseqR_adv_load_samples, eval=FALSE}
SRRControl <- abseqReport("SRR_CTRL")
SRRExp <- abseqReport("SRR_EXP")
```

then comparing _all_ samples in `SRRControl` with _all_ samples in `SRRExp`
can be done using [`+` and `report`](#customize-cmp).

```{r abseqR_adv_compare_old_new, eval=FALSE}
# short for SRRControl[[1]] + SRRControl[[2]] + ... + SRRExp[[1]] + ...
all.samples <- Reduce("+", c(SRRControl, SRRExp))
report(all.samples, outputDir = "SRRControl_vs_SRRExp")
```

> **Important**: The sample names in `SRR_CTRL` and `SRR_EXP` _must_ be unique.


## Lazy loading

In the previous section, the `SRRControl` dataset was loaded using
`SRRControl <- abseqReport("SRR_CTRL")` because its return value was required
before it can be used to compare with `SRRExp` in
`all.samples <- Reduce("+", c(SRRControl, SRRExp))`.
However, this is inefficent because `SRRControl <- abseqReport("SRR_CTRL")`
will **regenerate** all visuals and reports.
This dataset might have already been analyzed long before the `SRRExp`
dataset came along.

Instead, the following function call will let `abseqReport` know that it should
_do nothing_ and return what it usually returns (a _named list_ of samples in `SRRControl`).

```{r abseqR_adv_lazy_load, eval=FALSE}
# in essence, this is identical to SRRControl <- abseqReport("SRR_CTRL"),
# but will not regenerate plots and reports!
SRRControl.lazy <- abseqReport("SRR_CTRL", report = 0)

# exactly the same return value
stopifnot(names(SRRControl.lazy) == names(SRRControl))
```

The same applies to the `SRRExp` sample.

## Fine-tuning reports 

In the previous section, the `report` parameter of `abseqReport` was used to
"load" the samples in `SRRControl` without actually plotting any data. 
The `report` parameter is capable of accepting 4 values:

1. `abseqReport("SRR_CTRL", report = 0)` does nothing and returns a named list of
samples in the directory "SRR_CTRL".

2. `abseqReport("SRR_CTRL", report = 1)` plots PNGs but **does not** generate
HTML reports. That is, it will only create PNG plots of the data files generated
by `r sabseqPy()` without collating them into a HTML document.

3. `abseqReport("SRR_CTRL", report = 2)` plots PNGs and generates HTML reports, but
the graphs in the HTML reports are **static**. That is, it does exactly what
`report = 1` does, but also collects them and embeds the PNGs into
a standalone HTML report.

4. `abseqReport("SRR_CTRL", report = 3)` plots PNGs and interactive HTML reports.
That is, it does exactly what `report = 2` does, but also adds interactivity to
the embedded PNGs using [plotly](https://cran.r-project.org/package=plotly).
This is the default behaviour when `report` is not specified.

In all 4 cases, it will always return a named list of all samples in the
directory `SRR_CTRL`.


## Fine-tuning parallelization

`abseqReport` also accepts an optional parameter `BPPARAM`. This parameter
will be passed into `BiocParallel::bplapply` for parallelization. More
information regarding the accepted values to `BPPARAM` can be found in
BiocParallel's
[page](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html).

Below is a simplified example of using 4 cores and serializing the loop.

```{r abseqR_adv_bpparam, eval=FALSE}

# use 4 CPU cores
nproc <- 4
samples <- abseqReport(dataPath,
                       BPPARAM = BiocParallel::MulticoreParam(nproc))


# run sequentially - no multiprocessing
samples <- abseqReport(dataPath,
                       BPPARAM = BiocParallel::SerialParam())
```

# abseqR on example dataset {#abseqR-interpret}

```{r abseqR_plot_path_setup, include=FALSE}
# [s]ingle sample [dir]ectory
sdir <- file.path(dataPath, "auxiliary", "PCR1")
# [m]ulti sample [dir]ectory
mdir <- file.path(dataPath, "auxiliary", "PCR1_vs_PCR2_vs_PCR3")

read_png <- function(path) {
    if (file.exists(path)) {
        #rasterGrob(as.raster(readPNG(path)), interpolate = TRUE)
        knitr::include_graphics(path)
    } else {
        stop("File at", path, "not found, fatal.")
    }
}
```

This section will walk through the plots generated by `r sabseqR()` on the
provided dataset.

The visualizations and analyses can be broken down into 5 categories:

1. Sequence quality
2. V-(D)-J germline abundance
3. Productivity analysis
4. Clonotype diversity analysis
5. Overlapping clonotypes analysis

## Sequence quality

The plots described in this section can be found in
the `annot` and `abundance` directory of `PCR1`
or in the `Summary` and `Quality` tab in `PCR1`'s HTML report.

### Sequence length

The sequence length distribution is a simple way of validating the quality
of a sequencing run. The histogram is expected to show a large proportion of
sequences falling within the expected lengths.

```{r seq-len, fig.cap="Sequence length distribution of PCR1. Histogram of (merged) sequence lengths.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "annot", "PCR1_all_clones_len_dist.png"))
```

Figure \@ref(fig:seq-len) plots sequence length (x-axis) against proportion (y-axis).
A similar plot with outliers removed can be found in the same directory.

### Alignment quality

Recall that the filtering criteria of `r sabseqPy()` consist of:

1. Bitscore
2. Subject start index
3. Query start index
4. Alignment length

These criteria aim to remove low quality sequences, however, setting the
optimal filtering criteria for `r sabseqPy()` is challenging --
stringent values might filter too many sequences while lenient values might retain
low quality sequences.

The alignment quality heatmaps generated in `r sabseqR()` shows the relationship
between alignment lengths and the filtering criteria to help determine the percentage
of sequences falling within a given range.

For example, Figure \@ref(fig:align-qual) shows one of the 5 heatmaps: bitscore
against V germline alignment length.

```{r align-qual, fig.cap="Bitscore vs V germline alignment length in PCR1. Heatmap of bitscore vs alignment length shows percentage of sequences in a given value range.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "abundance", "PCR1_igv_align_quality_bitscore_hm_static.png"))
```

### Insertions, deletions, and mismatches

Insertions or deletions (indels) and mismatches
can be used as an indicator for sequence quality.

Figure \@ref(fig:indel) shows the rate of indels in `PCR1`. This graph plots the 
percentage (y-axis) of insertions or deletions (x-axis) in the V germlines of `PCR1`.
A similar plot for rate of mismatches in V germlines can be found in the same directory.

```{r indel, fig.cap="Rate of insertions and deletions in PCR1. The percentage of indels found within the V germlines of PCR1.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "abundance", "PCR1_igv_gaps_dist.png"))
```

## V-(D)-J germline abundance

The plots in this section can be found in the `abundance` directory
of `PCR1` or in the `Abundance` tab in `PCR1`'s HTML report.

### Germline abundance

The proportions of V-(D)-J germlines is essential in some experiment designs.
For example, it can be used to validate that the germline abundance of an
in-house antibody library is in-line with the natural antibody repertoire.
Experiments that artifically amplify certain germline families can also
be validated similarly using this plot.

```{r vgermline, fig.cap="V family germline distribution in PCR1. The percentage of IGHV families after germline annotation using IgBLAST.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "abundance", "PCR1_igv_dist_family_level.png"))
```

Figure \@ref(fig:vgermline) shows the percentage of IGHV families in `PCR1`.
The granularity varies between V-family (e.g. `IGHV3`) and
V-gene (e.g. `IGHV3-9`); these plots are available
in the same directory. The same applies to D and J germlines.


### V-J germline associations

In addition to Figure \@ref(fig:vgermline), it might be of interest to visualize the
recombination process of V and J germlines.
Figure \@ref(fig:vjassoc) summarizes the associations between V
and J family germlines in a plot generated using `r CRANpkg("circlize")`.

```{r vjassoc, fig.cap="V-J family germline association in PCR1. Segment size represents germline proportion while the thickness of the arcs shows the proportion of associations between V and J germline families. This plot was heavily inspired by [VDJTools](https://github.com/mikessh/vdjtools/))", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "abundance", "PCR1_vjassoc.png"))
```

## Productivity analysis

The plots described in this section can be found in the `productivity` directory
of `PCR1` or in the `Productivity` tab in `PCR1`'s HTML report.

Briefly, the main factors affecting the productiveness of a sequence by
`r sabseq()`'s interpretation are:

1. Misaligned V-J germline coding frame
3. Presence of stop condons
2. Non-multiple of 3 indels within a framework or complementarity-determining region

Any sequence that satisfies at least one of the above condition will be classified
as unproductive.

`r sabseqR()` summarizes the productivity of sequences in `PCR1` in Figure \@ref(fig:prod-summ).
Factors that cause sequences to be unproductive are colour coded as such:

1. Green -- sequences that contains at least one stop codon _and_ has a frameshift
2. Cyan -- sequences _without stop codons_ that has a frameshift
3. Purple -- _in-frame_ sequences that contains at least one stop codon

```{r prod-summ, fig.cap="Productivity rate of sequences in PCR1. This plot shows the percentage of productive and unproductive sequences, the reason for unproductive sequences are colour coded.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "productivity", "PCR1_productivity.png"))
```

### Frameshifts

Figure \@ref(fig:frameshift) shows the percentage of sequences that are
out-of-frame due to either misaligned V-J coding frame or non-multiple of 3 indels
in one of the framework or complementarity-determining regions.

```{r frameshift, fig.cap="Rate of in-frame and out-of-frame sequences in PCR1. Misaligned V-J frame or non-multiple of 3 indels in either one of the framework or complementarity-determining regions causes a frameshift and therefore renders the sequence unproductive.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "productivity", "PCR1_vjframe_dist.png"))
```

### Stop codons

Another contributing factor of unproductive sequences are the presence of
stop codons. Stop codons may exist originally in the sequence or can be
introduced by upstream indels that are not a multiple of 3.
Figure \@ref(fig:stopcod) shows the hot spots for stop codons segregated by
framework and complementarity-determining regions.

```{r stopcod, fig.cap="Proportion of stop codons in any given CDR or FR of out-of-frame sequences in PCR1. The percentages show the frequency of stop codons in a given region relative to the total number of stop codons present.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "productivity", "PCR1_stopcodon_region_outframe.png"))
```

The figure above shows the percentage of stop codons in regions of _out-of-frame_ sequences.
As discussed earlier, these stop codons may be introduced by the frameshift itself, hence
a similar plot for _in-frame_ sequences can also be found within the same directory.

### Indels and mismatches

Some sequences are productive despite having indels and mismatches. This occurs
when indels are a multiple of 3 and mismatches do not introduce stop codons.
The following figures plot indels and mismatches for each germline,
framework region, and complementarity-determining region on _productive sequences_ (unless
specified otherwise).

Figure \@ref(fig:mismatches), Figure \@ref(fig:gaps), and Figure \@ref(fig:gaps-out)
plots the proportion of mismatches in productive sequences,
indels in productive sequences, and indels in out-of-frame (unproductive) sequences
for framework region 3 (FR3).
The motivation behind these plots is to quickly identify the quality of productive
sequences.

For example, the number of mismatches in framework regions and IGJ
are expected to be low because they are relatively conserved regions. Similarly,
the number of indels in productive sequences are expected to be low or some
multiple of 3.

```{r mismatches, fig.cap="Proportion of mismatches in productive sequences of PCR1.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "productivity", "PCR1_fr3_mismatches_dist.png"))
```

```{r gaps, fig.cap="Proportion of indels in productive sequences of PCR1.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "productivity", "PCR1_fr3_gaps_dist.png"))
```

```{r gaps-out, fig.cap="Proportion of indels in out-of-frame sequences of PCR1.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "productivity", "PCR1_fr3_gaps_dist_out_of_frame.png"))
```

Similar plots for other regions and IGV, IGD, and IGJ can be found in the
same directory.

<!-- TODO: missing plot 1: skipped IGV productive dist,
IGV inframe unproductive dist, IGV out-of-frame dist-->


## Clonotype diversity analysis

The plots described in this section can be found in the `diversity` directory
of `PCR1` or in the `Diversity` tab in `PCR1`'s HTML report.

`r sabseq()` only conducts diversity analysis on clones that are productive.

### Sequence duplication, rarefaction, and recapture analysis

To estimate repertoire diversity, `r sabseqR()` employs 3 commonly used techniques:

_Sequence duplication levels_ in Figure \@ref(fig:dup) plots the proportion (y-axis) of singletons, doubletons,
and higher-order clonotypes (x-axis).

_Rarefaction curve_ in Figure \@ref(fig:rare) plots the number of deduplicated clonotypes (y-axis)
from varying sample sizes (x-axis). For every sample size, the number of deduplicated
clonotypes were sampled 5 times and the average value was used.

_Percent recapture_ in Figure \@ref(fig:recap) plots the percentage of clonotypes recaptured (y-axis) in
a capture-recapture experiment from varying sample sizes (x-axis).
For every sample size, the percentage of recaptured clonotypes denotes the average
of 5 repeated capture-recapture experiments.

In all the figures, the complementarity-determining region (CDR)
used to define a "clonotype" is mapped on the `linetype` aesthetic. Similar plots
for framework regions (FR) and the entire variable domain is also available within
the same directory.

```{r dup, fig.cap="Proportion of duplicated clonotypes in PCR1. Higher-order duplication levels starting from 10 are binned.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "diversity", "PCR1_cdr_duplication.png"))
```

```{r rare, fig.cap="Rarefaction curve of clonotypes in PCR1. The number of deduplicated sequences are taken over the mean of 5 resampling rounds, where the shaded areas indicate 95% confidence interval.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "diversity", "PCR1_cdr_rarefaction.png"))
```

```{r recap, fig.cap="Capture-recapture of clonotypes in PCR1. The number of recaptured sequences are taken over the mean of 5 resampling rounds, where the shaded areas indicate 95% confidence interval.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "diversity", "PCR1_cdr_recapture.png"))
```

### Spectratype

Spectratypes are histograms of clonotype lengths.

Figure \@ref(fig:spectra) shows a CDR3 amino acid spectratype with outliers removed.
Spectratypes for other FRs and CDRs are available in the same directory.

```{r spectra, fig.cap="CDR3 amino acid spectratype for PCR1 with outliers removed.", echo=FALSE, out.width="100%"}
read_png(file.path(sdir, "diversity", "spectratypes", "PCR1_cdr3_spectratype_no_outliers.png"))
```

#### Amino acid composition logos

In addition to spectratypes, `r sabseqR()` also visualizes the amino acid
composition of each FRs and CDRs in a set of bar plots.
Figure \@ref(fig:comp) shows the composition of `PCR1`'s CDR3.
The left shows an unscaled composition logo, where the proportion is normalized
using the total number of available amino acids in a given position. The right
shows a scaled composition logo, where the proportion is nomalized using
the total number of clonotypes. Similar plots for other FRs and CDRs
are available in the same directory.

```{r comp, fig.cap="Amino acid composition logo for PCR1's CDR3. The unscaled (left) and the scaled (right) composition logos are colour coded and grouped by their physicochemical properties.", echo=FALSE, fig.wide=TRUE}
unscaled <- file.path(sdir, "diversity", "composition_logos", "CDR3", "PCR1_cumulative_logo.png")
scaled <- file.path(sdir, "diversity", "composition_logos", "CDR3", "PCR1_cumulative_logo_scaled.png")
img1 <-  rasterGrob(as.raster(readPNG(unscaled)), interpolate = TRUE)
img2 <- rasterGrob(as.raster(readPNG(scaled)), interpolate = TRUE)
grid.arrange(img1, img2, ncol = 2)
```


## Overlapping clonotype analysis

The plots described in this section can be found in the `clonotype_analysis`
directory of `PCR1_vs_PCR2_vs_PCR3` or in the `Clonotypes` tab in
`PCR1 vs PCR2 vs PCR3`'s HTML report.

Since overlapping clonotype analysis deals with _overlapping_ clonotypes,
this analysis only applies when `compare` was supplied with at
least one sample comparison. Earlier, the call to `abseqReport`
had `compare = c("PCR1, PCR2, PCR3")`, therefore
`PCR1`, `PCR2,` and `PCR3` are compared against each other.

Throughout this analysis, a clonotype is synonymous to its CDR3 amino acid sequence.


### Scatter plot of clonotype frequencies

In order to visualize the linearity between any pair of samples, `r sabseqR()` plots
a scatter plot of every possible combination. Figure \@ref(fig:scatter) shows
one of them, plotting the clonotype frequencies in `PCR2` against `PCR1`.

The scatter plot:

* has $log_{10}$-scaled clonotype frequencies
* has a point for each clonotype
    * the coordinate of each point denotes the $log_{10}(frequency)$ in the sample
    on the x and y axis respectively
    * point sizes are mapped to the mean frequency of a clonotype
* has marginal density plots colour coded as such:
    * blue: density of _overlapping clonotypes_
    * purple: density of _non-overlapping clonotypes_
    * grey: density of _all clonotypes_
    

```{r scatter, fig.cap="Log-scaled scatter plot of clonotype frequencies in PCR1 and PCR2. Point size denotes mean frequency of the 2 samples and marginal density plots are colour coded by overlapping (blue), non-overlapping (purple), and all (grey) clonotypes.", echo=FALSE, out.width="100%"}
read_png(file.path(mdir, "clonotype_analysis", "PCR1_vs_PCR2_clone_scatter.png"))
```

This plot is heavily inspired by [VDJTools](https://github.com/mikessh/vdjtools/).

### Top 10 clones


Figure \@ref(fig:topclones) offers a simple overview of the top 10 clones found
in each sample. Since the clonotypes are colour coded, overlapping clonotypes
can easily be identified within the top 10 of each samples. Note that the
proportions are scaled relative to the top 10 clones in the respective samples.

This plot complements the scatter plot; it displays the most abundant clonotypes
in each sample with the amino acid sequence in the legend. 

```{r topclones, fig.cap="Top 10 clonotypes from PCR1, PCR2, and PCR3. The clonotype proportions displayed are scaled relative to the top 10 clones in each sample.", echo=FALSE, out.width="100%"}
read_png(file.path(mdir, "clonotype_analysis", "PCR1_PCR2_PCR3_top10Clonotypes.png"))
```


### Overlapping clones

While Figure \@ref(fig:topclones) is capable of showing overlapping clones,
it is restricted to the top 10 clones from each sample. Figure \@ref(fig:overlap)
aims to overcome the restriction by using a venn diagram to visualize the number
of overlapping (and non-overlapping) clones from each sample. Each number within
the venn diagram shows the number of unique clonotypes that are overlapping (in
an intersection) or are non-overlapping (not in any intersection).
That is, by taking the sum of all the numbers in a sample segment,
it becomes the number of unique clonotypes found in that sample.


```{r overlap, fig.cap="Number of unique overlapping clones found in PCR1, PCR2, and PCR3. The numbers in an intersection denotes the number of unique clones that are shared between the samples involved in the said intersection.", echo=FALSE, out.width="100%"}
read_png(file.path(mdir, "clonotype_analysis", "PCR1_PCR2_PCR3_cdr3_clonotypeIntersection.png"))
```

Note that this venn diagram will __not__ be plotted if there are more than 5
samples.

### Correlations

In addition to Figure \@ref(fig:scatter), the linearity of clonotype frequencies
between samples can be directly quantified using Pearson's correlation coefficient.
Figure \@ref(fig:corr) shows the plot generated by `r CRANpkg("ggcorrplot")` used to visualize
pearson coefficients. A similar plot using Spearman's correlation coefficient (rank-based)
is also available in the same directory.

```{r corr, fig.cap="Pearson correlation between PCR1, PCR2, and PCR3. Values denote the pearson correlation coefficient of the clonotypes frequencies between the samples. These values will appear with a cross 'x' to signify an insignificant coefficient if the p-value of the coefficient is larger than 0.05.", echo=FALSE, out.width="100%"}
read_png(file.path(mdir, "clonotype_analysis", "pearson.png"))
```


### Clustering samples

The `r CRANpkg("vegan")` package was used to calculate distances between samples.
The distances between samples are calculated using its clonotype frequencies by
applying methods from Morisita-Horn's overlap index, Jaccard index, and Dice's coefficient.

Figure \@ref(fig:cluster) shows a dendrogram plotted using
Morisita-Horn's overlap index. The length of each line denotes the distance
between the 2 samples or clusters it is connected to.
Other dendrograms using Jaccard and Dice's formula are available in the same directory.

```{r cluster, fig.cap="Morisita-Horn distances of PCR1, PCR2, and PCR3. The distances are calculated using clonotype frequencies and are visualized as the length of the lines connecting samples or clusters.", echo=FALSE, out.width="100%"}
read_png(file.path(mdir, "clonotype_analysis", "morisita_horn.png"))
```


# Miscellaneous

## Dataset {#example-data}

The dataset used in the above examples
was obtained from a combination of synthetic sample datasets generated
using [MiXCR](https://github.com/milaboratory/mixcr)'s program 
[here](http://files.milaboratory.com/mixcr/paper/mixcr-test-1.2-SNAPSHOT.jar). 
Firstly, three distinct samples were generated, each simulated with the following parameters
in `MiXCR`:

```{r mixr-test-params, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| Parameter     | sample 1      | sample 2      | sample 3      |
|---------------|---------------|---------------|---------------|
| reads         |  10000        |  10000        | 10000         |
| clones        |  5000         |  5000         | 2000          |
| seed          |  4228         |  2428         | 2842          |
| conf          | MiSeq-300-300 | MiSeq-300-300 | MiSeq-300-300 |
| loci          |  IGH          | IGH           | IGH           |
| species       | hsa           | hsa           | hsa           |
"
cat(tabl)
```

Following that, an arbitrary number of sequences were randomly
drawn from each of the 3 samples and randomly amplified.
This process was repeated 3 times, resulting in a final repertoire
of 3 samples, named PCR1, PCR2, and PCR3.

Finally, these 3 samples were analyzed by `r sabseqPy()`. The command used to
analyze these samples are as follows:

```{bash abseqR__data_abseqPy_run, eval=FALSE}
abseq -y params.yml
```

where the contents of `params.yml` is:

```yaml
# params.yml
defaults:
    bitscore: 300
    sstart: 1-3
    alignlen: 250
    outdir: ex
    task: all
    threads: 1
---
file1: PCR1.fasta
name: PCR1
---
file1: PCR2.fasta
name: PCR2
---
file1: PCR3.fasta
name: PCR3
```

`r sabseqPy()`'s analysis output on these 3 samples are contained
within the dataset described in this vignette.

# Session Info

This vignette was rendered in the following environment:
```{r abseqR_session_info, echo=FALSE}
sessionInfo()
```

[^Repseq]: Repertoire sequencing
[^windows_biocparallel]: The performace offered by
[BiocParallel](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html) may differ across OSes
[^compare-ws]: Trailing and leading whitespace between sample names are trimmed. That is, "PCR1,PCR2" is identical to
"PCR1 , PCR2"
